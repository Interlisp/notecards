"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const child_process = require("child_process");
const cli_table_2_json_1 = require("cli-table-2-json");
const dockermachine_cli_js_1 = require("dockermachine-cli-js");
//import * as _ from "lodash";
const snakeCase = require("lodash.snakecase");
const nodeify_ts_1 = require("nodeify-ts");
const exec = child_process.exec;
const splitLines = function (input) {
    return input.replace(/\r/g, "").split("\n");
};
const array2Oject = function (lines) {
    return lines.reduce(function (object, linep) {
        const line = linep.trim();
        if (line.length === 0) {
            return object;
        }
        const parts = line.split(":");
        let key = parts[0];
        const value = parts.slice(1).join(":");
        key = snakeCase(key);
        object[key] = value.trim();
        return object;
    }, {});
};
const extractResult = function (result) {
    const extracterArray = [
        {
            re: / build /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                lines.forEach(function (line) {
                    const re = /Successfully built (.*)$/;
                    const str = line;
                    const m = re.exec(str);
                    if (m !== null) {
                        if (m.index === re.lastIndex) {
                            re.lastIndex++;
                        }
                        // View your result using the m-variable.
                        // eg m[0] etc.
                        resultp.success = true;
                        resultp.imageId = m[1];
                    }
                });
                resultp.response = lines;
                return resultp;
            },
        },
        {
            re: / run /,
            run(resultp) {
                resultp.containerId = resultp.raw.trim();
                return resultp;
            },
        },
        {
            re: / ps /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                resultp.containerList = cli_table_2_json_1.cliTable2Json(lines);
                return resultp;
            },
        },
        {
            re: / images /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                //const debug = require('debug')('docker-cli-js:lib/index.js extractResult images');
                //debug(lines);
                resultp.images = cli_table_2_json_1.cliTable2Json(lines);
                return resultp;
            },
        },
        {
            re: / network ls /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                //const debug = require('debug')('docker-cli-js:lib/index.js extractResult images');
                //debug(lines);
                resultp.network = cli_table_2_json_1.cliTable2Json(lines);
                return resultp;
            },
        },
        {
            re: / inspect /,
            run(resultp) {
                const object = JSON.parse(resultp.raw);
                resultp.object = object;
                return resultp;
            },
        },
        {
            re: / info /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                resultp.object = array2Oject(lines);
                return resultp;
            },
        },
        {
            re: / search /,
            run(resultp) {
                const lines = splitLines(resultp.raw);
                resultp.images = cli_table_2_json_1.cliTable2Json(lines);
                return resultp;
            },
        },
        {
            re: / login /,
            run(resultp) {
                resultp.login = resultp.raw.trim();
                return resultp;
            },
        },
        {
            re: / pull /,
            run(resultp) {
                resultp.login = resultp.raw.trim();
                return resultp;
            },
        },
        {
            re: / push /,
            run(resultp) {
                resultp.login = resultp.raw.trim();
                return resultp;
            },
        },
    ];
    extracterArray.forEach(function (extracter) {
        const re = extracter.re;
        const str = result.command;
        const m = re.exec(str + " ");
        if (m !== null) {
            if (m.index === re.lastIndex) {
                re.lastIndex++;
            }
            // View your result using the m-constiable.
            // eg m[0] etc.
            return extracter.run(result);
        }
    });
    return result;
};
exports.dockerCommand = (command, options = {
    currentWorkingDirectory: undefined,
    echo: true,
    env: undefined,
    machineName: undefined,
}) => __awaiter(this, void 0, void 0, function* () {
    let machineconfig = "";
    if (options.machineName) {
        machineconfig = yield new dockermachine_cli_js_1.DockerMachine()
            .command(`config ${options.machineName}`)
            .then((data) => data.machine.config);
    }
    const execCommand = `docker ${machineconfig} ${command}`;
    const execOptions = {
        cwd: options.currentWorkingDirectory,
        env: Object.assign({ DEBUG: "", HOME: process.env.HOME, PATH: process.env.PATH }, options.env),
        maxBuffer: 200 * 1024 * 1024,
    };
    const raw = yield new Promise((resolve, reject) => {
        const childProcess = exec(execCommand, execOptions, (error, stdout, stderr) => {
            if (error) {
                return reject(Object.assign(new Error(`Error: stdout ${stdout}, stderr ${stderr}`), Object.assign({}, error, { stdout, stderr, innerError: error })));
            }
            resolve(stdout);
        });
        if (options.echo) {
            childProcess.stdout.on("data", (chunk) => {
                process.stdout.write(chunk.toString());
            });
            childProcess.stderr.on("data", (chunk) => {
                process.stderr.write(chunk.toString());
            });
        }
    });
    return extractResult({
        command: execCommand,
        raw,
    });
});
class Docker {
    constructor(options = {
        currentWorkingDirectory: undefined,
        echo: true,
        env: undefined,
        machineName: undefined,
    }) {
        this.options = options;
    }
    command(command, callback) {
        return nodeify_ts_1.default(exports.dockerCommand(command, this.options), callback);
    }
}
exports.Docker = Docker;
class Options {
    constructor(machineName, currentWorkingDirectory, echo = true, env) {
        this.machineName = machineName;
        this.currentWorkingDirectory = currentWorkingDirectory;
        this.echo = echo;
        this.env = env;
    }
}
exports.Options = Options;
